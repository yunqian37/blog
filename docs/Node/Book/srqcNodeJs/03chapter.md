### 为什么要异步I/O

web应用已经不再是单台服务器就能胜任的时代了，在跨网络的结构下，并发已经是现代编程中的标准配备了。

##### 1.用户体验

前端获取资源的速度取决于后端的响应速度。

​	如果第一个资源需要M毫秒，第二个资源需要N毫秒。

​		同步的方式两者总耗时为M+N		异步的方式为max(M,N)

+ 第一个资源获取不会阻塞第二个资源
+ 随着网站或应用不断膨胀，数据将会分布到多台服务器上，分布式将会是常态。
+ 只有后端能够快速响应资源，才能让前端的体验变好

##### 2.资源分配

利用单线程远离多线程死锁、状态同步等问题

利用异步I/O，让单线程远离阻塞，以更好的使用CPU



### 异步I/O实现现状

##### 1.异步I/O与非阻塞I/O

​	操作心态内核对于I/O只有两种方式：阻塞与非阻塞。在调用阻塞I/O时，应用程序需要等待I/O完成才返回结果。

​	阻塞I/O特点：调用后一定要等到系统内核层面完成所有操作后调用才结束

​							阻塞I/O造成CPU等待I/O，浪费等待时间，CPU的处理能力不能得到充分利用

​	非阻塞I/O：为了提高性能，内核提供了非阻塞I/O。非阻塞I/O调用之后会立即返回

​			问题：由于完整的I/O并没有完成，立即返回的并不是业务层期望的数据，而仅仅是当前调用的状态。为了获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成。这种重复调用判断操作是否完成的技术叫做轮询

**轮询技术**

+ read：它是最原始、性能最低的一种。通过重复调用来检查I/O的状态来完成完整数据的读取。在得到最终数据前CPU一直耗用在等待上。
+ select：在read的基础上改进的一种方案，通过对文件描述上的事件状态来进行判断。它采用一个1024长度的数组来存储状态，所以它最多可以同时检查1024个文件描述符。
+ poll：较select有所改进，采用链表的方式避免数组长度的限制，其次它能避免不需要的检查。但是当文件描述符较多的时候它的性能还是十分低下的
+ epoll：Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进行休眠，直到事件发生将它唤醒。是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率高
+ kqueue：实现方式与epoll类似，不过仅在FreeBSD系统下存在

注：轮询技术满足了非阻塞I/O确保获取完整数据的需求，但是对于应用程序而言，他任然只能算是一种同步，因为应用程序仍需要等待I/O完全返回，依旧花费了很多时间来等待

##### 2.理想的非阻塞异步I/O

Linux下原生提供一种异步I/O方式，通过信号或回调来传递数据。---> AIO

AIO缺陷：仅支持内核I/O中的O_DIRECT方式读取，导致无法利用系统缓存

##### 3.现实的异步I/O

通过让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进行传递，这就轻松实现了异步I/O



### Node的异步I/O

##### 1.事件循环

Node自身的执行模型

在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次的循环体过程称为Tick。每个Tick的过程就是查看是否有事件待处理。

##### 2.观察者

每个事件循环中有一个或者多个观察者，判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件

##### 3.请求对象

从js发起调用到内核执行完成I/O操作的过渡过程中存在的一种中间产物，所有的状态都保存在这个对象中。包括送入线程池等待执行以及I/O操作完毕后的回调处理

##### 4.执行回调

组装好请求对象、送入I/O线程池等待执行。实际上是完成了异步I/O的第一部分，回调通知是第二部分

线程池中的I/O操作调用完毕之后，会将获取的结果存在req -> result属性上。然后调用PostQueuedCompletionStatus()通知IOCP，告知当前对象操作已经完成

注：1、事件循环是一个典型的生产者/消费者模型。异步I/O、网络请求等则是事件的生产者，源源不断为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。

​		2、从JavaScript调用Node的核心模块，核心模块调用C++内建模块，内建模块通过libuv进行系统调用，这是Node里经典的调用方式

​		3、事件循环、观察者、请求对象、I/O线程池 ===> Node异步I/O模型的基本要素

​		4、在Node中除了JS是单线程外，Node自身其实是多线程的，只是I/O线程使用的CPU较少



### 非I/O的异步API

##### 1.定时器

setTimeout()和setInterval()与浏览器中的API是一致的，实现原理与异步I/O比较类似，只是不需要I/O线程池的参与。创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次Tick执行是会从该红黑树中迭代取出定时器对象，检查是否超过定时时间。超过则形成一个事件，回调函数将立即执行。

问题：精确度不对

##### 2.process.nextTick()

process.nextTick()回调函数保存在一个数组中

每轮询环中会将数组中的回调函数全部执行完

该方法操作相对较为轻量，每次调用该方法只会将回调函数放入队列中，在下一轮Tick是取出执行。

##### 3.setImmediate()

setImmediate()结果保存在链表中

在每轮循环中执行链表中的一个回调函数

与process.nextTick()方法十分类似，都是将回调函数延迟执行。process.nextTick()中的回调函数执行的优先级高于setImmediate()。

原因：事件循环对观察者的检查有先后顺序，process.nextTick()属于idle观察者，setImmediate()属于check观察者。在每一个轮询环检查中，idle观察者先于I/O观察者，I/O观察者先于check观察者



### 事件驱动与高性能服务器

事件驱动的实质：通过主循环加事件触发的方法来运行程序

**服务器模型**

+ 同步式：一次只能处理一个请求，并且其余请求都处于等待状态
+ 每进程/每请求：为每个请求启动一个进程，这样可以处理多个请求，但是它不具备扩展性，因为系统资源只有那么多
+ 每线程/每请求：为每个请求启动一个线程来处理，尽管线程比进程要轻量，但是由于每个线程都占用一定内存，当大并发氢气到来时，内存将会很快用光，导致服务器缓慢。

注：Node通过事件驱动的方式处理请求，无须为每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销



**总结：事件循环时异步实现的核心，它与浏览器中的执行模型基本保持了一致**