### CommonJS规范

CommonJs规范为JS定制了一个美好的愿景 --- 希望JS能够在任何地方运行



### CommonJs的模块规范

+ 模块引用：require()方法接受模块标识，以此引入一个模块的API到当前上下文中

+ 模块定义：exports对象用于导出当前模块的方法或变量，他是唯一的导出口

  ​					module对象代表模块自身，exports是module的属性

+ 模块标识：传递给require()方法的参数

CommonJs模块导出和引入机制使得用户完全不必考虑变量污染



### Node的模块实现

1:路径分析		2:文件定位		3:编译执行

**Node模块分类：** 

​	核心模块(Node提供的模块)

​			核心模块在Node源码编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中

​	文件模块(用户编写的模块)

​			文件模块是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程



**优先从缓存加载**

​		Node对引入过的模块都会进行缓存，以减少二次引入时的开销。浏览器缓存文件，Node缓存编译和执行之后的对象

​		不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，核心模块的缓存检查先于文件模块的缓存检查



**加载速度：核心模块缓存加载 > 文件模块缓存加载 > 核心模块 > 路径形成的文件模块 > 自定义模块** 



**模块标识符** 

+ 核心模块（例：http、fs、path...)
+ . 或 .. 开始的相对路径文件模块
+ 以 / 开始的绝对路径模块
+ 非路径形成的文件模块，例：自定义模块

注：自定义模块的加载速度慢是因为：他的生成方式与js的原型链或作用域链的查找方式十分类似，Node会逐个尝试模块路径中的路径，直到找到目标文件为止。文件路径越深模块查找耗时越多。



**文件定位** 

+ 文件扩展名分析：require()在分析标识符的过程中出现标识符不包含文件扩展名的情况下Node会按 .js、.json、.node的次序补足扩展名依次尝试。建议在非.js的扩展名的情况下都携带扩展名
+ 目录分析和包：require()通过分析文件扩展名之后可能没有查找到对应文件，但却得到一个目录，此时Node会将目录当作一个包来处理。如果模块路径数组都被遍历完毕依然没有查找到目标文件则会抛出查找失败的异常。





**模块编译**

在Node中每个文件模块都是一个对象，每个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。

载入方式：

+ .js文件：通过fs模块同步读取文件后编译执行
+ .node文件：这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件
+ .json文件：通过fs模块同步读取文件后，用JSON.parse()解析返回结果
+ 其余扩展名文件：都被当作.js文件载入。



**核心模块**

核心模块分为C/C++编写和JS编写的两个部分，C/C++存放在Node项目的src目录下，JS文件存放在lib目录下

js核心模块的编译过程：

+ 转存为C/C++代码
+ 编译js核心模块

C/C++核心模块的编译过程：

+ 内建模块的组织形式
+ 内建模块的导出



**包与NPM**

由包结构(用于组织包中的各种文件)和包描述(描述包的相关信息)文件两个部分组成

包结构：

+ package.json：包描述文件
+ bin：用于存放可执行二进制文件的目录
+ lib：用于存放js代码的目录
+ doc：用于存放文档的目录
+ test：用于存放单元测试用例的代码

包描述文件与NPM：

​	包描述文件用于表达非代码相关的信息 ==> package.json

+ name：包名
+ descript：包简介
+ version：版本号
+ dependencies：当前包所需要依赖的包列表
+ devDependencies：一些模块只在开发时需要依赖
+ script：脚本说明对象
+ 。。。。。省略一些不常见的

NPM常用功能

​	CommonJS包规范时理论，NPM是其中的一种实践，借助NPM可以帮助用户快速安装和管理依赖包

局域NPM

​	企业内部使用，可以保持更新的中心化，不至于让各个小项目各自维护相同功能的模块，杜绝通过复制黏贴实现代码共享的行为



**前后端共用模块**

​	暂缺



