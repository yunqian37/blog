### 函数式编程

在js中函数作为一等公民使用上非常自由，无论调用它、或者作为参数、或者作为返回值均可。

**高阶函数**

高阶函数可以把函数作为参数，或是将函数作为返回值的参数

js中的高阶函数：forEach()、map()、reduce()、reduceRight()、filter()、every()、some()

**偏函数用法**

创建一个调用另一个部分	参数或变量已经预置的函数	的函数的用法



### 异步编程的优势与难点

**优势**

基于事件驱动的非阻塞I/O模型，可以使CPU与I？O并不互相依赖等待，让资源更好的利用。对于网络应用：并行使得各个单点之间能够更有效地组织起来。

Node为了解决编程模型中阻塞I/O的性能问题才用了单线程模型

借助异步I/O模型及V8高性能引擎突破单线程的性能瓶颈，让js在后端达到使用价值

**难点**

+ 异常处理：将异常作为回调函数的第一个实参传回，如果为空置则表明异步调用没有任何异常抛出。编写异步方法时必须执行调用者传入的回调函数，正确传递回异常供调用者判断
+ 函数嵌套过深
+ 阻塞代码：即延时操作，在统一规划业务逻辑之后可以调用setTimeout()
+ 多线程编程：child_process是基础API，cluster模块是更深层次的应用
+ 异步转同步：



### 异步编程解决方案

**事件发布/订阅模式**

事件监听器是一种广泛用于异步编程的模式，是回调函数的事件化。

订阅事件是一个高阶函数的应用，事件发布/订阅模式可以实现一个事件与多个回调函数的关联，这些回调函数又称为事件侦听器。

事件发布/订阅模式自身并无同步异步调用的问题，但是Node中emit()调用多半是伴随事件循环而异步触发的，所以说事件发布/订阅广泛应用于异步编程

事件侦听器模式也是一种钩子(hook)机制，利用钩子导出内部数据或状态给外部调用者。通过这种方式可以使编程者不用关注组件是如何启动和执行的，只需关注在需要的事件点上即可。

Node对于事件发布/订阅的机制做的处理：

+ 如果一个事件添加了超过10个侦听器，将会得到一条警告。因为侦听器过多有可能导致内存泄漏或存在过多占用CPU的情景
+ EventEmitter会检查是否对error事件添加过侦听器，添加了则会将这个错误交给侦听器处理，否则这个错误将会作为异常抛出

